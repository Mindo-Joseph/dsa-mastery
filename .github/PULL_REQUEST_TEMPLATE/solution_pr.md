## Problem

**LeetCode #**:
**Title**:
**Difficulty**: Easy | Medium | Hard
**Pattern**:

**Problem Statement**:
<!-- Brief summary of the problem -->

---

## My Approach

### Pattern Recognition
<!-- How did you identify this pattern? What were the key signals? -->

### Solution Strategy
<!-- Explain your approach in plain English -->

### Why This Approach?
<!-- What alternatives did you consider? Why did you choose this one? -->

---

## Complexity Analysis

### Time Complexity: O(?)
**Proof**:
<!-- Explain why this is the time complexity -->

### Space Complexity: O(?)
**Proof**:
<!-- Explain why this is the space complexity -->

---

## Implementation Notes

### Edge Cases Handled:
- [ ] Empty input
- [ ] Single element
- [ ] Duplicates
- [ ] Negative numbers
- [ ] Integer overflow
- [ ] Other:

### Rust-Specific Considerations:
<!-- Any ownership, borrowing, or lifetime issues? -->
<!-- Performance optimizations specific to Rust? -->

---

## Alternative Approaches Considered

### Approach 2:
- **What**:
- **Time**: O(?)
- **Space**: O(?)
- **Why not chosen**:

---

## Questions for Review

1. Can this be optimized further?
2. Are there edge cases I missed?
3. Is this the expected senior-level solution?

---

## Test Results

```
cargo test --package dsa_mastery --lib patterns::<pattern>::<problem>
```

- [ ] All tests pass
- [ ] Handles edge cases
- [ ] Performance is optimal

---

**Ready for senior-level review** âœ“
