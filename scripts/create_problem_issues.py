#!/usr/bin/env python3
"""
Create GitHub issues for daily problems
Each problem becomes an issue you can track and close
"""

import os
import json
import subprocess
from pathlib import Path
from datetime import datetime


def create_issue(problem_info: dict, pattern: str):
    """
    Create a GitHub issue for a problem

    Args:
        problem_info: Dict with problem details
        pattern: Pattern name

    Returns:
        Issue number
    """
    title = f"[{pattern}] {problem_info.get('title', 'Problem')}"

    body = f"""## Problem: {problem_info.get('title', 'Untitled')}

**Pattern:** {pattern}
**Difficulty:** {problem_info.get('difficulty', 'Unknown')}
**Problem Number:** {problem_info.get('number', 'N/A')}

### Description

{problem_info.get('description', 'No description provided')}

### Test Cases

```
{problem_info.get('test_cases', 'No test cases provided')}
```

### Tasks

- [ ] Understand the problem
- [ ] Identify pattern application
- [ ] Write solution
- [ ] Write tests
- [ ] Pass all tests
- [ ] Submit PR
- [ ] Get review
- [ ] Merge

### Solution File

Create: `src/patterns/{pattern.lower().replace(' ', '_')}/problem_XXX.rs`

### Complexity Target

- Time: O(?)
- Space: O(?)

---

*Generated by DSA Mastery automation*
*Close this issue when you've solved and merged the problem*
"""

    labels = [
        pattern.lower().replace(' ', '-'),
        problem_info.get('difficulty', 'medium').lower(),
        'problem'
    ]

    # Create issue using gh CLI
    cmd = [
        'gh', 'issue', 'create',
        '--title', title,
        '--body', body,
        '--label', ','.join(labels)
    ]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        # Extract issue number from output (format: "https://github.com/user/repo/issues/123")
        issue_url = result.stdout.strip()
        issue_number = issue_url.split('/')[-1]

        print(f"‚úÖ Created issue #{issue_number}: {title}")
        return issue_number

    except subprocess.CalledProcessError as e:
        print(f"‚ùå Failed to create issue: {e.stderr}")
        return None


def parse_problems_from_text(text: str):
    """
    Parse problem information from Gemini response text

    Returns:
        List of problem dicts
    """
    problems = []
    lines = text.split('\n')

    current_problem = {}

    for line in lines:
        line = line.strip()

        # Look for problem numbers
        if line.startswith('**Problem Number:') or line.startswith('Problem Number:'):
            if current_problem:
                problems.append(current_problem)
            current_problem = {
                'number': line.split(':')[1].strip().replace('**', ''),
                'title': '',
                'difficulty': 'Medium',
                'description': '',
                'test_cases': ''
            }

        # Look for titles
        elif ('**Title:' in line or 'Title:' in line) and current_problem:
            current_problem['title'] = line.split(':')[1].strip().replace('**', '')

        # Look for difficulty
        elif ('**Difficulty:' in line or 'Difficulty:' in line) and current_problem:
            current_problem['difficulty'] = line.split(':')[1].strip().replace('**', '')

        # Look for descriptions
        elif ('**Description:' in line or 'Description:' in line) and current_problem:
            desc_start = line.index(':') + 1
            current_problem['description'] = line[desc_start:].strip()

    if current_problem:
        problems.append(current_problem)

    return problems


def create_issues_from_daily_problems(pattern: str):
    """
    Read daily problems file and create GitHub issues

    Args:
        pattern: Pattern name (e.g., "Two Pointers")

    Returns:
        List of issue numbers
    """
    pattern_slug = pattern.lower().replace(' ', '_')
    problems_file = Path(f"daily-problems/{pattern_slug}_problems.md")

    if not problems_file.exists():
        print(f"‚ö†Ô∏è  No problems file found: {problems_file}")
        return []

    # Read problems
    with open(problems_file) as f:
        content = f.read()

    # Parse problems
    problems = parse_problems_from_text(content)

    if not problems:
        print("‚ö†Ô∏è  Could not parse problems from file")
        return []

    print(f"\nüìã Creating {len(problems)} GitHub issues for {pattern}...\n")

    issue_numbers = []
    for problem in problems:
        issue_num = create_issue(problem, pattern)
        if issue_num:
            issue_numbers.append(issue_num)

    # Save issue numbers
    issues_file = Path(f"progress/{pattern_slug}_issues.json")
    issues_file.parent.mkdir(exist_ok=True)

    with open(issues_file, 'w') as f:
        json.dump({
            'pattern': pattern,
            'created': datetime.now().isoformat(),
            'issues': issue_numbers
        }, f, indent=2)

    print(f"\n‚úÖ Created {len(issue_numbers)} issues")
    print(f"üíæ Saved to: {issues_file}")

    return issue_numbers


def main():
    """CLI interface"""
    import sys

    if len(sys.argv) < 2:
        print("Usage: python3 create_problem_issues.py <pattern>")
        print("\nExample:")
        print("  python3 create_problem_issues.py 'Two Pointers'")
        sys.exit(1)

    pattern = sys.argv[1]

    # Check if gh CLI is available
    try:
        subprocess.run(['gh', '--version'], capture_output=True, check=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        print("‚ùå GitHub CLI (gh) not found")
        print("\nInstall with:")
        print("  sudo apt install gh")
        print("  gh auth login")
        sys.exit(1)

    issue_numbers = create_issues_from_daily_problems(pattern)

    if issue_numbers:
        print(f"\nüéØ View your issues:")
        print(f"   gh issue list --label problem")
        print(f"\nüíª Start solving:")
        print(f"   gh issue view {issue_numbers[0]}")


if __name__ == '__main__':
    main()
