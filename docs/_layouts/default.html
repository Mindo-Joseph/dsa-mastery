<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    {% seo %}

    <!-- Apple-inspired styles -->
    <link rel="stylesheet" href="{{ '/assets/css/custom.css' | relative_url }}">

    <!-- Font preload -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    <meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
    <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000000">
  </head>
  <body>
    <!-- Breadcrumb navigation -->
    {% if page.show_breadcrumb %}
    <div class="container-lg">
      <nav class="breadcrumb no-print" aria-label="Breadcrumb">
        <a href="{{ '/' | relative_url }}">Home</a>
        <span class="breadcrumb-separator" aria-hidden="true">›</span>
        {% if page.category %}
        <a href="{{ page.category_url | relative_url }}">{{ page.category }}</a>
        <span class="breadcrumb-separator" aria-hidden="true">›</span>
        {% endif %}
        <span aria-current="page">{{ page.title }}</span>
      </nav>
    </div>
    {% endif %}

    <!-- Main content -->
    <main class="container-lg">
      {{ content }}
    </main>

    <!-- Footer -->
    <footer class="container-lg">
      <div class="footer no-print">
        <p>DSA Mastery</p>
        <p>AI-enhanced learning for Google L5+ standards</p>
        {% if site.github.private != true %}
        <p>
          <a href="{{ site.github.repository_url }}">GitHub</a>
          {% if site.github.license %}
          <span style="color: var(--text-tertiary);"> · </span>
          <a href="{{ site.github.repository_url }}/blob/main/LICENSE">{{ site.github.license.name }}</a>
          {% endif %}
        </p>
        {% endif %}
        <p style="font-size: 12px; margin-top: 16px;">
          Built with Rust, Gemini RAG, and Claude Code
        </p>
      </div>
    </footer>

    <!-- Intersection Observer animations -->
    <script>
      (function() {
        'use strict';

        // Smooth scroll for anchor links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
          anchor.addEventListener('click', function(e) {
            const href = this.getAttribute('href');
            if (href === '#') return;

            e.preventDefault();
            const target = document.querySelector(href);
            if (target) {
              const offsetTop = target.getBoundingClientRect().top + window.pageYOffset - 80;
              window.scrollTo({
                top: offsetTop,
                behavior: 'smooth'
              });
            }
          });
        });

        // Sophisticated scroll-driven reveal animations
        const observerOptions = {
          threshold: [0, 0.1, 0.5],
          rootMargin: '0px 0px -80px 0px'
        };

        const revealObserver = new IntersectionObserver((entries) => {
          entries.forEach((entry, index) => {
            if (entry.isIntersecting && entry.intersectionRatio >= 0.1) {
              // Stagger animation delay based on position
              const delay = index * 50;
              setTimeout(() => {
                entry.target.style.opacity = '1';
                entry.target.style.transform = 'translateY(0)';
              }, delay);

              // Unobserve once animated
              revealObserver.unobserve(entry.target);
            }
          });
        }, observerOptions);

        // Apply animations when DOM is ready
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initAnimations);
        } else {
          initAnimations();
        }

        function initAnimations() {
          // Reveal cards with stagger
          const cards = document.querySelectorAll('.card, .feature-card, .stat-card, .pattern-card');
          cards.forEach((el, i) => {
            el.style.opacity = '0';
            el.style.transform = 'translateY(24px)';
            el.style.transition = `opacity 0.6s cubic-bezier(0.16, 1, 0.3, 1), transform 0.6s cubic-bezier(0.16, 1, 0.3, 1)`;
            el.style.transitionDelay = `${Math.min(i * 0.05, 0.3)}s`;
            revealObserver.observe(el);
          });

          // Reveal sections
          const sections = document.querySelectorAll('.section');
          sections.forEach((el) => {
            el.style.opacity = '0';
            el.style.transform = 'translateY(32px)';
            el.style.transition = 'opacity 0.8s cubic-bezier(0.16, 1, 0.3, 1), transform 0.8s cubic-bezier(0.16, 1, 0.3, 1)';
            revealObserver.observe(el);
          });

          // Stats counter animation on scroll into view
          const statValues = document.querySelectorAll('.stat-value');
          const statsObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
              if (entry.isIntersecting) {
                const el = entry.target;
                const text = el.textContent;
                if (text !== '—' && !isNaN(text)) {
                  animateCounter(el, parseInt(text));
                }
                statsObserver.unobserve(el);
              }
            });
          }, { threshold: 0.5 });

          statValues.forEach(el => statsObserver.observe(el));
        }

        function animateCounter(element, target) {
          const duration = 1500;
          const start = 0;
          const startTime = performance.now();

          function update(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Ease-out cubic
            const easeProgress = 1 - Math.pow(1 - progress, 3);
            const current = Math.floor(start + (target - start) * easeProgress);

            element.textContent = current;

            if (progress < 1) {
              requestAnimationFrame(update);
            } else {
              element.textContent = target;
            }
          }

          requestAnimationFrame(update);
        }

        // Parallax effect on scroll (subtle)
        let ticking = false;
        window.addEventListener('scroll', () => {
          if (!ticking) {
            window.requestAnimationFrame(() => {
              const scrolled = window.pageYOffset;
              const hero = document.querySelector('.hero');
              if (hero && scrolled < 800) {
                hero.style.transform = `translateY(${scrolled * 0.3}px)`;
                hero.style.opacity = Math.max(1 - scrolled / 600, 0);
              }
              ticking = false;
            });
            ticking = true;
          }
        });

        // Prefers reduced motion
        if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
          document.querySelectorAll('*').forEach(el => {
            el.style.animation = 'none';
            el.style.transition = 'none';
          });
        }
      })();
    </script>
  </body>
</html>
